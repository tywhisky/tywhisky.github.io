<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Postgresql on Happy Coding</title><link>//tywhisky.github.io/tags/postgresql/</link><description>Recent content in Postgresql on Happy Coding</description><generator>Hugo</generator><language>en-us</language><copyright>Tainef</copyright><lastBuildDate>Wed, 10 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="//tywhisky.github.io/tags/postgresql/index.xml" rel="self" type="application/rss+xml"/><item><title>PostgreSQL 分区和分片</title><link>//tywhisky.github.io/posts/partition-and-shading-on-postgresql/</link><pubDate>Wed, 10 Jan 2024 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/partition-and-shading-on-postgresql/</guid><description>&lt;div id="outline-container-headline-1" class="outline-2"&gt;
&lt;h2 id="headline-1"&gt;
分区
&lt;/h2&gt;
&lt;div id="outline-text-headline-1" class="outline-text-2"&gt;
&lt;p&gt;
分区表并不是每天都要用到的，但在某些情况下，尤其是当你有一个预计会不断增长的大容量表时，分区表就显得尤为重要。&lt;/p&gt;
&lt;p&gt;
在 PostgreSQL 下拥有 Hot Table 隐患时进行删除操作是很灾难性的，一个长期运行的查询将会遍历每一条数据，标记为 dead 后执行操作，在这过程中不会释放任何空间。但有了分区，删除就变成了简单的 DROP TABLE。 它可以立即执行，成本可以忽略不计（分区还有其他好处）。当然，代价是需要重点维护。&lt;/p&gt;
&lt;div id="outline-container-headline-2" class="outline-3"&gt;
&lt;h3 id="headline-2"&gt;
分区操作
&lt;/h3&gt;
&lt;div id="outline-text-headline-2" class="outline-text-3"&gt;
&lt;p&gt;
 – 列出所有已存在的表&lt;/p&gt;
&lt;p&gt;
 – 决定应创建哪些新分区（如果有的话）并创建它们，提前三天将未来的分区调出来，为操作提供一些缓冲，以防出错。&lt;/p&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;CREATE&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;TABLE&lt;/span&gt; widget_20221005 PARTITION &lt;span style="color:#66d9ef"&gt;OF&lt;/span&gt; widget
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;FOR&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;VALUES&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;FROM&lt;/span&gt; (&lt;span style="color:#e6db74"&gt;&amp;#39;2022-10-05&amp;#39;&lt;/span&gt;) &lt;span style="color:#66d9ef"&gt;TO&lt;/span&gt; (&lt;span style="color:#e6db74"&gt;&amp;#39;2022-10-06&amp;#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;ALTER&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;TABLE&lt;/span&gt; widget DETACH partition widget_20221005;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;DROP&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;TABLE&lt;/span&gt; widget_20221005;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
INSERT 和 UPDATE 都发生在父表上，因此分区完全从正常的应用程序逻辑中抽象出来。这样我们就完成了一次简单的分区操作。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-headline-3" class="outline-2"&gt;
&lt;h2 id="headline-3"&gt;
分片
&lt;/h2&gt;
&lt;div id="outline-text-headline-3" class="outline-text-2"&gt;
&lt;p&gt;
一种将 Postgres 数据库表分割成更小表的技术，通常用于在组成数据库实例集群的多个节点上横向分发数据，更多部署在多节点集群。&lt;/p&gt;
&lt;div id="outline-container-headline-4" class="outline-3"&gt;
&lt;h3 id="headline-4"&gt;
使用 Citus 分片操作
&lt;/h3&gt;
&lt;div id="outline-text-headline-4" class="outline-text-3"&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;create&lt;/span&gt; extension citus;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;SELECT&lt;/span&gt; create_distributed_table(&lt;span style="color:#e6db74"&gt;&amp;#39;table&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;shard_column&amp;#39;&lt;/span&gt;, shard_count :&lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#ae81ff"&gt;256&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;SELECT&lt;/span&gt; &lt;span style="color:#f92672"&gt;*&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;FROM&lt;/span&gt; citus_add_node(&lt;span style="color:#e6db74"&gt;&amp;#39;worker_node_address&amp;#39;&lt;/span&gt;, &lt;span style="color:#e6db74"&gt;&amp;#39;192.168.0.2&amp;#39;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-sql"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;rebalance:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;SELECT&lt;/span&gt; rebalance_table_shards();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
除了简单方便外，使用 Citus 分片的好处还有性能：由于分片本质上也是散列分区的一种形式，因此分区的一些性能优势也适用于分片。 特别是，autovacuum 会在集群中的所有 Citus 分片上并行运行。&lt;/p&gt;</description></item><item><title>PostgreSQL 索引总结</title><link>//tywhisky.github.io/posts/postgresql-%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/postgresql-%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/</guid><description>&lt;p&gt;
Postgres 中有许多的索引类型，对应着不同的使用场景。在这篇总结中我们将对
所有可用的索引类型进行一个概述，并且解释 B-trees 这个最常见的索引类型的不同使用方式。&lt;/p&gt;
&lt;p&gt;
索引是一种从数据表中高效检索数据的方式，他只在相关联的数据量相对小时比较有用（也就是说，检索行的条件 - the WHERE clause - 是选择性的）。B-tree 索引也通常用于避免排序。&lt;/p&gt;
&lt;div id="outline-container-headline-1" class="outline-2"&gt;
&lt;h2 id="headline-1"&gt;
索引类型
&lt;/h2&gt;
&lt;div id="outline-text-headline-1" class="outline-text-2"&gt;
&lt;p&gt;
Postgres 支持多种不同类型的索引：&lt;/p&gt;
&lt;p&gt;
– B-Tree：这是当你使用 `CREATE INDEX` 时默认的得到的索引类型。几乎所有的数据库都有 B-tree 类型的索引。
B-trees 会试图保持平衡，树的每个分支中的数据量大致相同。因此，为找到行而必须遍历的级别数始终在同一范围内。
B-tree 索引能够有效的用于相等下的范围查询。它们可以对所有数据类型进行操作，也可用于检索 NULL 值。B 树设计为可以很好地处理缓存，即使只缓存了一部分。&lt;/p&gt;
&lt;p&gt;
– Hash Indexes：Postgres 10 之前的 Hash 索引只对等式比较有用，但是它们不是事务安全的，在崩溃之后必须手动重建。&lt;/p&gt;
&lt;p&gt;
– Generalized Inverted Indexes (GIN)：GIN 索引对于必须映射许多值到一条数据上时非常有用。
就像 B-tree 索引被优化用于一条数据只有单个 key value，GINs 索引在 array 类型的数据上的良好变现也会很适合大文本搜索。&lt;/p&gt;
&lt;p&gt;
– Generalized Search Tree (GiST) GiST 索引允许创建传统的平衡树结构，用于等价的和范围查询。很适合地理数据类型的大文本搜索。&lt;/p&gt;
&lt;p&gt;
我们这里主要讨论默认的 B-Tree 索引。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-headline-2" class="outline-2"&gt;
&lt;h2 id="headline-2"&gt;
为什么我的查询没有使用索引？
&lt;/h2&gt;
&lt;div id="outline-text-headline-2" class="outline-text-2"&gt;
&lt;p&gt;
实际业务中，Postgres planner 可能根本没有用到索引，这看起来没什么特别的原因，但是可能大多时候反而是正确的。&lt;/p&gt;
&lt;p&gt;
For example:&lt;/p&gt;</description></item></channel></rss>