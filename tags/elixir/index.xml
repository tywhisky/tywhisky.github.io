<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Elixir on Happy Coding</title><link>//tywhisky.github.io/tags/elixir/</link><description>Recent content in Elixir on Happy Coding</description><generator>Hugo</generator><language>en-us</language><copyright>Tainef</copyright><lastBuildDate>Mon, 01 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="//tywhisky.github.io/tags/elixir/index.xml" rel="self" type="application/rss+xml"/><item><title>Why Elixir is More Than Just Syntax Sugar Over Erlang</title><link>//tywhisky.github.io/posts/why-elixir-is-more-than-just-syntax-sugar-over-erlang/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/why-elixir-is-more-than-just-syntax-sugar-over-erlang/</guid><description>&lt;p&gt;
In my first year of using Elixir, I fell deeply in love with the language. However, I never really thought about why I liked Elixir so much. I mean, I can list many reasons, such as the Pipe Operator, Pattern Matching, and the powerful and flexible GenServer.&lt;/p&gt;
&lt;p&gt;
So, if you asked me, I would definitely say it’s the syntax. Coincidentally, I soon encountered a colleague. I was eager to recommend Elixir to him, but he said, &amp;#34;Elixir is just syntax sugar over Erlang, right? So why not just use Erlang?&amp;#34;&lt;/p&gt;</description></item><item><title>`Task.await/2` and `Task.await_many/2`</title><link>//tywhisky.github.io/posts/note-about-task/</link><pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/note-about-task/</guid><description>&lt;div id="outline-container-headline-1" class="outline-2"&gt;
&lt;h2 id="headline-1"&gt;
Introduction
&lt;/h2&gt;
&lt;div id="outline-text-headline-1" class="outline-text-2"&gt;
&lt;p&gt;
These days, I received a requirement to call several APIs simultaneously. It&amp;#39;s common sense to use Task for this purpose, and I naturally gravitated towards using it. However, I came across Task.yield/2 and wondered about the difference between it and Task.await. Let&amp;#39;s explore this.&lt;/p&gt;
&lt;div id="outline-container-headline-2" class="outline-3"&gt;
&lt;h3 id="headline-2"&gt;
Look some code snippets
&lt;/h3&gt;
&lt;div id="outline-text-headline-2" class="outline-text-3"&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; ms &lt;span style="color:#f92672"&gt;&amp;lt;-&lt;/span&gt; [&lt;span style="color:#ae81ff"&gt;2_000&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;4_000&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;6000&lt;/span&gt;] &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Task&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;async(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(ms); ms &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;|&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Enum&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;map(&lt;span style="color:#f92672"&gt;&amp;amp;&lt;/span&gt;&lt;span style="color:#a6e22e"&gt;Task&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;await(&amp;amp;1, &lt;span style="color:#ae81ff"&gt;3000&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# return [2000, 4000, 6000]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;for&lt;/span&gt; ms &lt;span style="color:#f92672"&gt;&amp;lt;-&lt;/span&gt; [&lt;span style="color:#ae81ff"&gt;2_000&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;4_000&lt;/span&gt;, &lt;span style="color:#ae81ff"&gt;6_000&lt;/span&gt;] &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Task&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;async(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(ms); ms &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;|&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Task&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;yield_many(&lt;span style="color:#ae81ff"&gt;3000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# return ** (EXIT) time out&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-headline-3" class="outline-3"&gt;
&lt;h3 id="headline-3"&gt;
Summary
&lt;/h3&gt;
&lt;div id="outline-text-headline-3" class="outline-text-3"&gt;
&lt;p&gt;
If you use await in Enum.map/2, each await picks up after the previous one finishes with a fresh 3-second timeout. Since each task blocks for 2 seconds before finishing, no timeout is triggered, but the total runtime exceeds the expected duration.&lt;/p&gt;</description></item><item><title>Trap Of `Map.update/4`</title><link>//tywhisky.github.io/posts/trap-of-map-update/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/trap-of-map-update/</guid><description>&lt;p&gt;
If we want to update a value in a map of which key we can not ensure it&amp;#39;s exist.
We can get the two way quickly:&lt;/p&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; record &lt;span style="color:#f92672"&gt;=&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;Map&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;get(map, key, [])
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Map&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;put(map, key, [new &lt;span style="color:#f92672"&gt;|&lt;/span&gt; record])&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Or we can use `Map.update/4`:&lt;/p&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Map&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;update(map, key, [], &lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; record &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; [new &lt;span style="color:#f92672"&gt;|&lt;/span&gt; record] &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
They are look like as the same completely. But the result is different,
the result by `Map.update/4` of above code is just get the last put in value.
It will only be empty or one item in the list.&lt;/p&gt;</description></item><item><title>Process exit rules for Elixir</title><link>//tywhisky.github.io/posts/process-exit-rules-for-elixir/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>//tywhisky.github.io/posts/process-exit-rules-for-elixir/</guid><description>&lt;div id="outline-container-headline-1" class="outline-3"&gt;
&lt;h3 id="headline-1"&gt;
With the beginning
&lt;/h3&gt;
&lt;div id="outline-text-headline-1" class="outline-text-3"&gt;
&lt;p&gt;
Process.flag(:trap_exit, true) 能够将 Process 发出的 Exit 信号捕获为 Msg,&lt;/p&gt;
&lt;p&gt;
型号的类型有三类, 分别是 :kill, :normal 和其他&lt;/p&gt;
&lt;p&gt;
其中被杀的进程本身捕获不到 :kill , 但是其他进程能捕获到, 可以看下面的例子。&lt;/p&gt;
&lt;p&gt;
:kill&lt;/p&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;worker &lt;span style="color:#f92672"&gt;=&lt;/span&gt; spawn(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;flag(&lt;span style="color:#e6db74"&gt;:trap_exit&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;receive&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; msg &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(msg, &lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;In worker&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(&lt;span style="color:#ae81ff"&gt;2000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;monitor &lt;span style="color:#f92672"&gt;=&lt;/span&gt; spawn(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;flag(&lt;span style="color:#e6db74"&gt;:trap_exit&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;link(worker)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;receive&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; msg &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(msg, &lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;In monitor&amp;#34;&lt;/span&gt;) &lt;span style="color:#75715e"&gt;# In monitor: {:EXIT, #PID&amp;lt;0.375.0&amp;gt;, :killed}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(&lt;span style="color:#ae81ff"&gt;1000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;exit(worker, &lt;span style="color:#e6db74"&gt;:kill&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;alive?(worker) &lt;span style="color:#f92672"&gt;|&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(&lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;Worker still alive?&amp;#34;&lt;/span&gt;) &lt;span style="color:#75715e"&gt;# Worker still alive?: false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
:normal&lt;/p&gt;
&lt;div class="src src-elixir"&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-elixir" data-lang="elixir"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;worker &lt;span style="color:#f92672"&gt;=&lt;/span&gt; spawn(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;flag(&lt;span style="color:#e6db74"&gt;:trap_exit&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;receive&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; msg &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(msg, &lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;In worker&amp;#34;&lt;/span&gt;) &lt;span style="color:#75715e"&gt;# In worker: {:EXIT, #PID&amp;lt;0.297.0&amp;gt;, :normal}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(&lt;span style="color:#ae81ff"&gt;2000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;monitor &lt;span style="color:#f92672"&gt;=&lt;/span&gt; spawn(&lt;span style="color:#66d9ef"&gt;fn&lt;/span&gt; &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;flag(&lt;span style="color:#e6db74"&gt;:trap_exit&lt;/span&gt;, &lt;span style="color:#66d9ef"&gt;true&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;link(worker)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;receive&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; msg &lt;span style="color:#f92672"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(msg, &lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;In monitor&amp;#34;&lt;/span&gt;) &lt;span style="color:#75715e"&gt;# In monitor: {:EXIT, #PID&amp;lt;0.844.0&amp;gt;, :normal}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;end&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;sleep(&lt;span style="color:#ae81ff"&gt;1000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;exit(worker, &lt;span style="color:#e6db74"&gt;:normal&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#a6e22e"&gt;Process&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;alive?(worker) &lt;span style="color:#f92672"&gt;|&amp;gt;&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;IO&lt;/span&gt;&lt;span style="color:#f92672"&gt;.&lt;/span&gt;inspect(&lt;span style="color:#e6db74"&gt;label&lt;/span&gt;: &lt;span style="color:#e6db74"&gt;&amp;#34;Worker still alive?&amp;#34;&lt;/span&gt;) &lt;span style="color:#75715e"&gt;# Worker still alive?: true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
如果用别的进程使用 :normal 去杀死一个进程, 那个进程是不会死的, 但是会当场受到
“死讯” , 如上第二段 Code 中, “In monitor” 将会在 worker 打印了死讯后 2 秒后
输出。&lt;/p&gt;</description></item><item><title>How Hot Reloading with Webpack and Phoenix</title><link>//tywhisky.github.io/posts/how-hot-reloading-for-phoenix-project/</link><pubDate>Fri, 15 Oct 2021 11:30:03 +0000</pubDate><guid>//tywhisky.github.io/posts/how-hot-reloading-for-phoenix-project/</guid><description>&lt;h3 id="live-reloading-和-hot-reloading-的区别"&gt;Live Reloading 和 Hot Reloading 的区别&lt;/h3&gt;
&lt;p&gt;Live Reloading是在浏览器进行更改后自动重新加载整个页面，使开发者不再需要切换浏览器手动点击 &lt;code&gt;cmd + r&lt;/code&gt; 。在这点上 Phoenix 通过 Phoenix LiveReload 可以提供开箱即用的支持，通过 &lt;code&gt;mix phx.new&lt;/code&gt; 创建的项目默认配置了 Phoenix LiveReload。&lt;/p&gt;
&lt;p&gt;但是，Live Reloading依然存在一个缺点，在开发现在越来越高度交互的 Web 应用时，频繁的代码改动与调试，意味着频繁的重新加载整个页面，很多情况你也许只希望修改一些样式，Live Reloading会显得尤为耗时，而为了解决这个问题，Hot Reloading 显得尤为重要。&lt;/p&gt;
&lt;h3 id="注意事项"&gt;注意事项&lt;/h3&gt;
&lt;p&gt;本文通过 React + Webpack 进行配置举例（因为自身业务），以前 React 的 Hot Reloading 是通过 &lt;code&gt;HMR&lt;/code&gt; (Hot Module Replacement) 实现的，因为一些&lt;a href="https://github.com/facebook/react/blob/f5d946da6be8d0cefd66ab3d029a55ab54ebb460/packages/react-refresh/README.md"&gt;技术原因&lt;/a&gt;不再使用这种方法。&lt;/p&gt;
&lt;p&gt;我们将使用 @pmmmwh/react-refresh-webpack-plugin 这个实验性的 Webpack 插件来实现，虽然这个插件在运行一段时间后，&lt;code&gt;webpack-dev-server&lt;/code&gt; 最终会吃掉大量内存，但是依然可以通过合适的配置和手动刷新，使其成为一个强大的工具。&lt;/p&gt;
&lt;h3 id="npm"&gt;NPM&lt;/h3&gt;
&lt;p&gt;首先在你的前端项目中执行，如果你是用的是 &lt;code&gt;yarn&lt;/code&gt; 请自行修改命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;npm install --save-dev @pmmmwh/
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;react-refresh-webpack-plugin
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;webpack-dev-server react-refresh
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;react-refresh-typescript
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="webpack-配置"&gt;Webpack 配置&lt;/h3&gt;
&lt;p&gt;在逻辑结构上我们将把 &lt;code&gt;webpack-dev-server&lt;/code&gt; 置于 Phoenix 应用之前。使 Webpack 能够将 websocket 注入页面，以便在需要进行 Hot Reloading 时通知浏览器。为了更好地理解，我们配置 &lt;code&gt;webpack-dev-server&lt;/code&gt; 启动在 4000 端口并且代理所有的请求到 4001 端口，也就是我们 Phoenix 应用运行的端口。所以现在浏览器仍然像 &lt;code&gt;http://localhost:4000&lt;/code&gt; 发出请求，但是将会被透明代理到 Phoenix。&lt;/p&gt;</description></item></channel></rss>