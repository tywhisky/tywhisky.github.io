<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Why Elixir is More Than Just Syntax Sugar Over Erlang - Happy Coding</title><link rel=icon type=image/png href=favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
In my first year of using Elixir, I fell deeply in love with the language. However, I never really thought about why I liked Elixir so much. I mean, I can list many reasons, such as the Pipe Operator, Pattern Matching, and the powerful and flexible GenServer.

So, if you asked me, I would definitely say it’s the syntax. Coincidentally, I soon encountered a colleague. I was eager to recommend Elixir to him, but he said, "Elixir is just syntax sugar over Erlang, right? So why not just use Erlang?"'><meta property="og:image" content="//tywhisky.github.io/"><meta property="og:url" content="//tywhisky.github.io/posts/why-elixir-is-more-than-just-syntax-sugar-over-erlang/"><meta property="og:site_name" content="Happy Coding"><meta property="og:title" content="Why Elixir is More Than Just Syntax Sugar Over Erlang"><meta property="og:description" content='In my first year of using Elixir, I fell deeply in love with the language. However, I never really thought about why I liked Elixir so much. I mean, I can list many reasons, such as the Pipe Operator, Pattern Matching, and the powerful and flexible GenServer.
So, if you asked me, I would definitely say it’s the syntax. Coincidentally, I soon encountered a colleague. I was eager to recommend Elixir to him, but he said, "Elixir is just syntax sugar over Erlang, right? So why not just use Erlang?"'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-01T00:00:00+00:00"><meta property="article:tag" content="Elixir"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why Elixir is More Than Just Syntax Sugar Over Erlang"><meta name=twitter:description content='In my first year of using Elixir, I fell deeply in love with the language. However, I never really thought about why I liked Elixir so much. I mean, I can list many reasons, such as the Pipe Operator, Pattern Matching, and the powerful and flexible GenServer.
So, if you asked me, I would definitely say it’s the syntax. Coincidentally, I soon encountered a colleague. I was eager to recommend Elixir to him, but he said, "Elixir is just syntax sugar over Erlang, right? So why not just use Erlang?"'><link href=//tywhisky.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=//tywhisky.github.io/css/main.a87126a5d38398207e58225b2d1a9faf97f546982f44b3ffb9715a264da36c90.css><link id=darkModeStyle rel=stylesheet type=text/css href=//tywhisky.github.io/css/dark.f163b79c6de51d14a766ff9f0563053de7f06a4d1bf7b85a59608bf96e566710.css media="(prefers-color-scheme: dark)"><script type=text/javascript src=//tywhisky.github.io/js/MathJax.js></script><script type=text/x-mathjax-config>
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel=stylesheet href=//tywhisky.github.io/katex/katex.min.css><script defer src=//tywhisky.github.io/katex/katex.min.js></script><script defer src=//tywhisky.github.io/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><div class=main><a href=//tywhisky.github.io/>Happy Coding</a></div><nav><a href=//tywhisky.github.io/>Home</a>
<a href=//tywhisky.github.io/posts>All posts</a>
<a href=//tywhisky.github.io/about>About</a>
<a href=//tywhisky.github.io/tags>Tags</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Why Elixir is More Than Just Syntax Sugar Over Erlang</h1><div class=meta>Posted on May 1, 2023</div></div><section class=body><p>In my first year of using Elixir, I fell deeply in love with the language. However, I never really thought about why I liked Elixir so much. I mean, I can list many reasons, such as the Pipe Operator, Pattern Matching, and the powerful and flexible GenServer.</p><p>So, if you asked me, I would definitely say it’s the syntax. Coincidentally, I soon encountered a colleague. I was eager to recommend Elixir to him, but he said, "Elixir is just syntax sugar over Erlang, right? So why not just use Erlang?"</p><p>This left me speechless because, yes, Elixir is indeed "just" syntax sugar.</p><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>What is <a href=https://en.wikipedia.org/wiki/Syntactic_sugar>Syntax Sugar</a></h2><div id=outline-text-headline-1 class=outline-text-2><p>Simply put, syntax sugar is something that makes your code easier to read, understand, and write. Honestly, I don't really like the term because sugar gives the impression of being superficial: "This thing doesn't help with performance; it only makes it easier to learn and understand, which only beginners need!"</p><p>At least, that’s how I felt when I first heard the term.</p><p>PS: It's said there's also something called "syntactic salt," which uses human-unfriendly syntax to make writing code more painful. It can also prevent coding errors, but it likely decreases programming efficiency by raising the syntax learning curve, making people salty with frustration…</p></div></div><div id=outline-container-headline-2 class=outline-2><h2 id=headline-2>Code is for Humans</h2><div id=outline-text-headline-2 class=outline-text-2><p>First, we should not underestimate the importance of syntax sugar. Code is written for humans, not machines. Easily understandable code means easier maintenance, more straightforward iteration of new features, easier test writing, clearer logic, and greater reliability.</p><p>Syntax sugar facilitates these goals, making it easier for the entire development team to practice them. You might think you don't need it, but development work often involves a whole team. In this context, the advantages provided by good syntax sugar are not negligible.</p></div></div><div id=outline-container-headline-3 class=outline-2><h2 id=headline-3>The Biggest Challenge in Software Engineering</h2><div id=outline-text-headline-3 class=outline-text-2><p>I once saw a quote on RubyChina that left a lasting impression: "I believe the biggest challenge in software engineering is continuously meeting business complexity while maintaining the maintainability of the project."</p><p>Yes, I completely agree, and the role of the language in this aspect is crucial. Additionally, functional languages are truly user-friendly. Many open-source libraries in OOP languages, especially the more complex and poorly written ones, leave you clueless when reading the source code on GitHub.</p><p>You can’t clearly see the runtime state just by looking at the code. You need to clone it, run it, and debug it to see the value of certain variables at specific times and states. Compared to procedural languages, functional languages eliminate the concept of time. When I open Elixir's source code, it's easy to understand because there are no tangled dependencies.</p><p>Everything has input and output. As long as you can imagine the input data, you can predict the output. This makes writing tests much easier, a significant advantage in maintaining project maintainability.</p></div></div><div id=outline-container-headline-4 class=outline-2><h2 id=headline-4>Let It Crash</h2><div id=outline-text-headline-4 class=outline-text-2><p>At first, I didn’t understand the "let it crash" design philosophy. I wondered if writing more maintainable code but causing every exception to crash was appropriate.</p><p>Many languages treat exceptions as a form of control flow. In some cases, only the ideal flow is described with if/else/case, and all other situations are designed as exceptions. Elixir does not use exceptions as a form of control flow. Exceptions are only used for things that are "almost impossible to happen under normal circumstances," such as database disconnections, HTTP request timeouts, and missing configuration files.</p><p>Anticipated situations are generally handled with `{:error, reason}` and pattern matching. However, as I learned more, I found it very reasonable. No program can handle all unexpected situations. In such cases, a simple restart to ensure the service doesn't go down is a better approach. For example, if your computer crashes due to a power outage, you just restart it without further investigation because it doesn’t make sense to do so.</p></div></div><div id=outline-container-headline-5 class=outline-2><h2 id=headline-5>Conclusion</h2><div id=outline-text-headline-5 class=outline-text-2><p>Elixir is not just a faster horse. As Henry Ford said, if he had asked people what they wanted, they would have said a faster horse, not a car. In my years of working with Elixir, I can’t say Elixir is a car, but it’s definitely not just a horse.</p><p>Elixir/Phoenix has changed many of my views on software development. For example, a basic web application involves some text coming in and some text going out. Why should we generate hundreds of objects in the process instead of thinking of it as a data stream passing through a server production line, transforming into the required format?</p><p>Ecto’s approach to validation for saving to the database is similar. ActiveRecord involves an object that must meet certain conditions to be saved. Ecto, however, is a data processing pipeline. Data must pass through the pipeline to reach the database, with inspectors ensuring quality at each step. If any inspection fails, the data isn’t saved.</p><p>The same type of data can pass through different pipelines based on different conditions. For example, user login and user registration can have different pipelines. Implementing conditional validation in some imperative languages is quite painful.</p><p>Therefore, the maintenance ease and clarity brought by Elixir’s syntax sugar become more apparent in larger projects, especially those with complex data flows. Yes, Elixir is just syntax sugar, but it’s more than just syntax sugar.</p></div></div></section><div class=post-tags></div></div></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="yourDisqusShortname",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tywhisky rel=me title=GitHub><svg class="feather"><use href="//tywhisky.github.io/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a></div><div class=footer-info>2026 Tainef | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>