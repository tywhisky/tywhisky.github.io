<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>- Happy Coding</title><link rel=icon type=image/png href=favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="为什么编辑器 Format “不可靠”
1. 编辑器拥有自己的 Format 规则
比如 VSCode 默认 TypeScript Format 规则：当我们不为 ts 文件指定任何 formatter 的情况下，默认将会按照这个规则执行 Code Format。
比如我这里设置结尾不允许存在分号，那么 onSave Format 的时候我们每次保存就会去掉所有的分号，但是如果我们定义的 prettier 配置文件中要求分号，那么我们就会将不同风格的代码提交上去，如果之后有人跑了全局 Format，就会出现非自己的改动，那才会是问题所在。

VSCode 配置

Prettier 规则


当然这里的问题并不是编辑器的缺陷抑或是全局 Format 的缺陷，问题的重点是 .vscode 等个人编辑器配置文件我们一般是不纳入 git 的版本管理，而不像 .prettierrc.json(prettier 规则配置文件) 拥有 git 记录，因此在我们引入了 prettier 的情况下，我们应该以 prettier 的规则为准（否则就不应该引入）。
当然通过在 Readme 中约束团队进行正确的编辑器 Format 配置也是一种方式，但是在前者（Prettier）已经存在的情况下，这种方式显然更风险和复杂，特别是每个人的编辑器可能还不同。
2. 编辑器插件版本导致的 Format 结果差异
要在编辑器中解决上诉的问题也很简单，安装 Prettier 插件，并且在默认 Formatter 处选中：


那么很显然这就会带来新的隐患：插件版本不同导致的 Format 风格差异。比如 A 成员用 Prettier 3.0，B 成员用 2.8，同一文件格式化结果不同。"><meta property="og:image" content="//tywhisky.github.io/"><meta property="og:url" content="//tywhisky.github.io/posts/whats-formatter/"><meta property="og:site_name" content="Happy Coding"><meta property="og:title" content="Happy Coding"><meta property="og:description" content="为什么编辑器 Format “不可靠” 1. 编辑器拥有自己的 Format 规则 比如 VSCode 默认 TypeScript Format 规则：当我们不为 ts 文件指定任何 formatter 的情况下，默认将会按照这个规则执行 Code Format。
比如我这里设置结尾不允许存在分号，那么 onSave Format 的时候我们每次保存就会去掉所有的分号，但是如果我们定义的 prettier 配置文件中要求分号，那么我们就会将不同风格的代码提交上去，如果之后有人跑了全局 Format，就会出现非自己的改动，那才会是问题所在。
VSCode 配置 Prettier 规则 当然这里的问题并不是编辑器的缺陷抑或是全局 Format 的缺陷，问题的重点是 .vscode 等个人编辑器配置文件我们一般是不纳入 git 的版本管理，而不像 .prettierrc.json(prettier 规则配置文件) 拥有 git 记录，因此在我们引入了 prettier 的情况下，我们应该以 prettier 的规则为准（否则就不应该引入）。
当然通过在 Readme 中约束团队进行正确的编辑器 Format 配置也是一种方式，但是在前者（Prettier）已经存在的情况下，这种方式显然更风险和复杂，特别是每个人的编辑器可能还不同。
2. 编辑器插件版本导致的 Format 结果差异 要在编辑器中解决上诉的问题也很简单，安装 Prettier 插件，并且在默认 Formatter 处选中： 那么很显然这就会带来新的隐患：插件版本不同导致的 Format 风格差异。比如 A 成员用 Prettier 3.0，B 成员用 2.8，同一文件格式化结果不同。"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Happy Coding"><meta name=twitter:description content="为什么编辑器 Format “不可靠” 1. 编辑器拥有自己的 Format 规则 比如 VSCode 默认 TypeScript Format 规则：当我们不为 ts 文件指定任何 formatter 的情况下，默认将会按照这个规则执行 Code Format。
比如我这里设置结尾不允许存在分号，那么 onSave Format 的时候我们每次保存就会去掉所有的分号，但是如果我们定义的 prettier 配置文件中要求分号，那么我们就会将不同风格的代码提交上去，如果之后有人跑了全局 Format，就会出现非自己的改动，那才会是问题所在。
VSCode 配置 Prettier 规则 当然这里的问题并不是编辑器的缺陷抑或是全局 Format 的缺陷，问题的重点是 .vscode 等个人编辑器配置文件我们一般是不纳入 git 的版本管理，而不像 .prettierrc.json(prettier 规则配置文件) 拥有 git 记录，因此在我们引入了 prettier 的情况下，我们应该以 prettier 的规则为准（否则就不应该引入）。
当然通过在 Readme 中约束团队进行正确的编辑器 Format 配置也是一种方式，但是在前者（Prettier）已经存在的情况下，这种方式显然更风险和复杂，特别是每个人的编辑器可能还不同。
2. 编辑器插件版本导致的 Format 结果差异 要在编辑器中解决上诉的问题也很简单，安装 Prettier 插件，并且在默认 Formatter 处选中： 那么很显然这就会带来新的隐患：插件版本不同导致的 Format 风格差异。比如 A 成员用 Prettier 3.0，B 成员用 2.8，同一文件格式化结果不同。"><link href=//tywhisky.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=//tywhisky.github.io/css/main.a87126a5d38398207e58225b2d1a9faf97f546982f44b3ffb9715a264da36c90.css><link id=darkModeStyle rel=stylesheet type=text/css href=//tywhisky.github.io/css/dark.f163b79c6de51d14a766ff9f0563053de7f06a4d1bf7b85a59608bf96e566710.css media="(prefers-color-scheme: dark)"><script type=text/javascript src=//tywhisky.github.io/js/MathJax.js></script><script type=text/x-mathjax-config>
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel=stylesheet href=//tywhisky.github.io/katex/katex.min.css><script defer src=//tywhisky.github.io/katex/katex.min.js></script><script defer src=//tywhisky.github.io/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><div class=main><a href=//tywhisky.github.io/>Happy Coding</a></div><nav><a href=//tywhisky.github.io/>Home</a>
<a href=//tywhisky.github.io/posts>All posts</a>
<a href=//tywhisky.github.io/about>About</a>
<a href=//tywhisky.github.io/tags>Tags</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title></h1><div class=meta>Posted on Jan 1, 1</div></div><section class=body><h2 id=为什么编辑器-format-不可靠>为什么编辑器 Format “不可靠”</h2><h3 id=1-编辑器拥有自己的-format-规则>1. 编辑器拥有自己的 Format 规则</h3><p>比如 VSCode 默认 TypeScript Format 规则：当我们不为 ts 文件指定任何 formatter 的情况下，默认将会按照这个规则执行 Code Format。</p><p>比如我这里设置结尾不允许存在分号，那么 <code>onSave</code> Format 的时候我们每次保存就会去掉所有的分号，但是如果我们定义的 prettier 配置文件中要求分号，那么我们就会将不同风格的代码提交上去，如果之后有人跑了全局 Format，就会出现非自己的改动，那才会是问题所在。</p><blockquote><p>VSCode 配置
<img src=image.png alt="Alt text">
Prettier 规则
<img src=image-1.png alt="Alt text"></p></blockquote><p>当然这里的问题并不是编辑器的缺陷抑或是全局 Format 的缺陷，问题的重点是 .vscode 等个人编辑器配置文件我们一般是不纳入 git 的版本管理，而不像 .prettierrc.json(prettier 规则配置文件) 拥有 git 记录，因此在我们引入了 prettier 的情况下，我们应该以 prettier 的规则为准（<strong>否则就不应该引入</strong>）。</p><p>当然通过在 Readme 中约束团队进行正确的编辑器 Format 配置也是一种方式，但是在前者（Prettier）已经存在的情况下，这种方式显然更风险和复杂，特别是每个人的编辑器可能还不同。</p><h3 id=2-编辑器插件版本导致的-format-结果差异>2. 编辑器插件版本导致的 Format 结果差异</h3><p>要在编辑器中解决上诉的问题也很简单，安装 Prettier 插件，并且在默认 Formatter 处选中：
<img src=image-2.png alt="Alt text">
<img src=image-3.png alt="Alt text">
那么很显然这就会带来新的隐患：插件版本不同导致的 Format 风格差异。比如 A 成员用 Prettier 3.0，B 成员用 2.8，同一文件格式化结果不同。</p><p>并且某些编辑器（如 VSCode）允许用户自定义覆盖 Prettier 选项（如 prettier.printWidth），可能无视项目配置，增加了风险。</p><h3 id=3-缺乏自动化流程的可靠性>3. 缺乏自动化流程的可靠性</h3><p>CI/CD 或 Git Hooks 无法依赖编辑器：
假设我们设置了自动化流程（如 pre-commit 或 CI 的格式检查）必须通过命令行调用 Prettier，无法使用编辑器功能。
当团队完全依靠编辑器来作为最终的 Format 风格时，就会遇到本地编辑器格式化通过，但 CI 因调用了命令行工具而报错的问题。</p><h2 id=为什么全局-format-不安全>为什么全局 Format “不安全”</h2><h3 id=1-速度问题>1. 速度问题</h3><p>当我们执行 <code>npm run prettier --write src/</code> 时，将会过滤 src 目录下的所有文件，尽管其中的非改动文件不会有影响，但是当项目非常巨大的时候还是会带来开发上地阻塞感以及不必要的性能浪费，因为在标准规范的流程下，“未作改动的文件不会被修改”这点应该是确定的。</p><p>因此这点我们可以通过 lint-staged 来仅格式化 Git 暂存区的文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// package.json
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;lint-staged&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;*.{js,ts,css,md}&#34;</span>: <span style=color:#e6db74>&#34;prettier --write&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-不遵守规范的开发者>2. 不遵守规范的开发者</h3><p>尽管我们设置了 pre-commit 在每次 commit 要求前都需要 Format Code，但是依然架不住有些人通过一些方式强行提交，比如：</p><blockquote><p>git commit -m &ldquo;hot fix&rdquo; &ndash;no-verify</p></blockquote><p>那这种情况下如果我们的 CI 没有 Format 相关的检查，他修改的这部分未格式化的内容就会被提交。</p><p>然后当下一位遵守规范的开发者，执行全局 Format 的时候，就会成为倒霉蛋（我的文件怎么全乱了！只能一个个对比去 discard 文件)。</p><p>当然，有了 Git 和 Code Review 等环节，这些都是可以追溯找到应该背锅的人的 XD。</p><h2 id=总结编辑器-format-vs-命令行-format>总结：编辑器 Format VS 命令行 Format</h2><p>那么到底应该是依靠编辑器 Format 还是命令行 Format 呢？答案应该是“我全都要”，但是以 <code>npm run prettier</code> 为最终标准。</p><p>编辑器 Auto Format 带来更高的开发效率，但是 <code>npm run prettier</code> 它直接依赖项目配置，结果更加确保一致性，适合团队协作和自动化流程。</p></section><div class=post-tags></div></div></div><div id=disqus_thread></div><script type=text/javascript>(function(){if(window.location.hostname=="localhost")return;var t,e=document.createElement("script");e.type="text/javascript",e.async=!0,t="yourDisqusShortname",e.src="//"+t+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by
Disqus.</a></noscript><a href=http://disqus.com/ class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tywhisky rel=me title=GitHub><svg class="feather"><use href="//tywhisky.github.io/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a></div><div class=footer-info>2026 Tainef | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer></div></body></html>